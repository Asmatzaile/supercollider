class:: Impulse
summary:: Impulse oscillator.
related:: Classes/Blip
categories::  UGens>Generators>Deterministic


Description::
Outputs non-bandlimited single sample impulses.


classmethods::

method::ar, kr

argument::freq
Frequency in Hertz. strong::freq:: may be negative.


argument::phase
Phase offset in cycles (0..1). Staying in this range offers a slight efficiency
advantage, though phase offsets outside this range are supported and wrapped
internally.

argument::mul
The output will be multiplied by this value.


argument::add
This value will be added to the output.

Discussion::
code::Impulse:: will output an impulse on the first sample (assuming no phase
offset).

When the initial code::freq = 0::, a single impulse is output on first sample,
followed by silence until the frequency changes.

Discussion::
code::Impulse:: will output a code::1.0:: on the first sample (assuming no
phase offset).

If the initial code::freq = 0::, a single impulse is output on first sample,
followed by silence until the frequency changes.

Supported rate combinations for code::(freq, phase):: are
code::(a,a)::, code::(a,k)::, code::(a,i)::,
code::(k,k)::, code::(k,i)::,
code::(i,k)::, code::(i,i)::.


Internally, code::Impulse:: is based on a wrapping phasor: when the phase wraps,
an impulse is output. Any strong::phase:: offset is added and wrapped before
the phase increment (determined by strong::freq::) is applied. Therefore, it is
the phase increment (freq) that triggers an impulse, not the phase offset. For
example, if you wanted to drive and impulse train directly by the phase,
code::Impulse:: would not support that. However, a small UGen network could
achieve this result:
code::
({ var f = 1000;
    HPZ1.ar(HPZ1.ar(Phasor.ar(rate: f * SampleDur.ir))) > 1e-5
}.plot(0.005)
);
::

Examples::

code::
{ Impulse.ar(800, 0.0, 0.5, 0) }.play

{ Impulse.ar(XLine.kr(800,100,5), 0.0,  0.5, 0) }.play
::

modulate phase:
code::
{ Impulse.ar(4, [0, MouseX.kr(0, 1)], 0.2) }.play;
::

an Impulse with frequency 0 returns a single impulse:
code::
SynthDef(\imp, { OffsetOut.ar(0, Impulse.ar(0)); FreeSelf.kr(Impulse.kr(0)); }).add;
fork { (1 / (1..60).scramble).do { |dt| Synth.grain(\imp);  dt.wait } };
::
